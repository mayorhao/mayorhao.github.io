<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Calm down and Coding on">
<meta property="og:type" content="website">
<meta property="og:title" content="MayorHao的秘密小屋">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="MayorHao的秘密小屋">
<meta property="og:description" content="Calm down and Coding on">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MayorHao的秘密小屋">
<meta name="twitter:description" content="Calm down and Coding on">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>MayorHao的秘密小屋</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">MayorHao的秘密小屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">小浩少校写字的地方</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            文章列表
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/15/2016-01-20-javascript-guide-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MayorHao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MayorHao的秘密小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/15/2016-01-20-javascript-guide-2/" itemprop="url">《JavaScript 权威指南》笔记（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-15T02:33:29+08:00">
                2016-08-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第10章-DOM"><a href="#第10章-DOM" class="headerlink" title="第10章 DOM"></a>第10章 DOM</h1><ol>
<li>DOM(文档对象模型)是针对 HTML 和 XML 文档的一个 API(应用程序编程接口)。</li>
<li><p>Node 类型</p>
<p> 每个节点都有一个 nodeType 属性,用于表明节点的类型。节点类型有12种。</p>
</li>
<li><p>每个节点都有一个 childNodes 属性,其中保存着一个 NodeList 对象。</p>
</li>
<li>nodeName 和 nodeValue 属性（需要先判断 nodeType）</li>
<li><p>将 NodeList 对象转换为数组</p>
<pre><code>function convertToArray(nodes){
    var array = null;
    try {
        array = Array.prototype.slice.call(nodes, 0); //针对非 IE 浏览器 } catch (ex) {
        array = new Array();
        for (var i=0, len=nodes.length; i &lt; len; i++){
            array.push(nodes[i]);
        }
    }
    return array;
}
</code></pre></li>
<li><p>每个节点都有一个 <code>parentNode</code> 属性。同胞节点有 <code>previousSibling</code> 和 <code>nextSibling</code> 属性。父节点的 <code>firstChild</code> 和 <code>lastChild</code> 属性分别指向其 <code>childNodes</code> 列表中的第一个和最后一个节点。</p>
</li>
<li><code>hasChildNodes()</code>在节点包含一或多个子节点的情况下返回 true</li>
<li>所有节点都有的最后一个属性是 <code>ownerDocument</code>,该属性指向表示整个文档的文档节点。</li>
<li><p>操作节点</p>
<ol>
<li><code>appendChild()</code>,用于向 childNodes 列表的末尾添加一个节点。如果传入到 appendChild()中的节点已经是文档的一部分了,那结果就是将该节点从原来的位置 转移到新位置。(如传入文档的第一个节点)</li>
<li><code>insertBefore()</code>接受两个参数:要插入的节点和作为参照的节点。 </li>
<li><code>replaceChild()</code>接受两个参数:要插入的节点和要替换的节点。</li>
<li><code>removeChild()</code>方法接受一个参数,即要移除的节点。</li>
</ol>
</li>
<li><p>其他方法</p>
<ol>
<li><code>cloneNode()</code>,参数 true 或 false 表示深浅复制</li>
<li><code>normalize()</code></li>
</ol>
</li>
<li><p>Document 类型</p>
<p>Document 类型表示文档。在浏览器中,document 对象是 HTMLDocument(继承自 Document 类型)的一个实例,表示整个 HTML 页面。而且,document 对象是 window 对象的一个 属性,因此可以将其作为全局对象来访问。</p>
</li>
<li><p>文档信息</p>
<p>document.url、document.domain、document.referrer</p>
</li>
</ol>
<h1 id="第11章-DOM-扩展"><a href="#第11章-DOM-扩展" class="headerlink" title="第11章 DOM 扩展"></a>第11章 DOM 扩展</h1><ol>
<li>Selectors API Level 1 的核心是两个方法:querySelector()和 querySelectorAll()。</li>
<li>querySelector()方法接收一个 CSS 选择符,返回与该模式匹配的第一个元素,如果没有找到匹配的元素,返回 null。</li>
<li>querySelectorAll()方法返回的是一个 NodeList 的实例。要取得返回的 NodeList 中的每一个元素,可以使用 item()方法,也可以使用方括号语法。</li>
<li>matchesSelector()方法，Selectors API Level 2规范为Element类型新增的一个方法。这个方法接收 一个参数,即 CSS 选择符,如果调用元素与该选择符匹配,返回 true;否则,返回 false。</li>
<li><p>HTML5 扩展</p>
<ol>
<li><p>与类相关的扩充</p>
<ol>
<li>getElementsByClassName()方法</li>
<li>classList 属性</li>
</ol>
</li>
<li><p>焦点管理</p>
<ol>
<li>document.activeElement 属性,这个 属性始终会引用 DOM 中当前获得了焦点的元素</li>
<li>document.hasFocus()方法,这个方法用于确定文档是否获得了焦点。</li>
</ol>
</li>
<li><p>HTMLDocument的变化</p>
<ol>
<li>readyState 属性：loading,正在加载文档；complete,已经加载完文档</li>
<li>兼容模式：compatMode 属性</li>
<li>head 属性</li>
</ol>
</li>
<li><p>插入标记</p>
<ol>
<li>innerHTML()</li>
<li>outerHTML()</li>
<li>insertAdjacentHTML()</li>
</ol>
</li>
<li><p>滚动</p>
</li>
</ol>
</li>
</ol>
<h1 id="第12章-DOM2-和-DOM3"><a href="#第12章-DOM2-和-DOM3" class="headerlink" title="第12章 DOM2 和 DOM3"></a>第12章 DOM2 和 DOM3</h1><ol>
<li>DOM1 级主要定义的是 HTML 和 XML 文档的底层结构。DOM2 和 DOM3 级则在这个结构 的基础上引入了更多的交互能力,也支持了更高级的 XML 特性。</li>
</ol>
<h1 id="第16章-HTML5-脚本编程"><a href="#第16章-HTML5-脚本编程" class="headerlink" title="第16章 HTML5 脚本编程"></a>第16章 HTML5 脚本编程</h1><ol>
<li><p>跨文本消息传递（XDM）</p>
<p> postMessage() 使用</p>
</li>
<li><p>原生拖放</p>
<ol>
<li><p>拖放事件</p>
<p> 拖动元素时，将依次触发下列事件：dragstart、drag、dragend。<br> 当某个元素被拖动到一个有效的放置目标上时，下列事件会依次发生：dragenter、dragover、dragleave 或 drop</p>
</li>
<li><p>dataTransfer 对象</p>
<p> 实现拖放操作时数据交换</p>
</li>
</ol>
</li>
<li><p>媒体元素</p>
</li>
<li><p>历史状态管理</p>
<p> history 对象 hashchange、pushState、popState、replaceState</p>
</li>
</ol>
<h1 id="第17章-错误处理与调试"><a href="#第17章-错误处理与调试" class="headerlink" title="第17章 错误处理与调试"></a>第17章 错误处理与调试</h1><ol>
<li><p>错误处理</p>
<ol>
<li><p>try-catch 语句</p>
<p> 若有 finally 子句，无论是否发生错误，甚至 return 语句，finally 子句都会执行。</p>
</li>
<li><p>抛出错误 throw</p>
</li>
</ol>
</li>
<li><p>常见的错误类型</p>
<ol>
<li>类型转换错误（使用全等和不全等操作符）</li>
<li>数据类型错误（基本类型使用 typeof 检测，对象使用 instanceof 检测）</li>
<li>通信错误（使用 Ajax）</li>
</ol>
</li>
<li><p>区分致命错误和非致命错误</p>
</li>
<li>把错误记录到服务器</li>
<li><p>调试技术</p>
<ol>
<li>将消息记录到控制台</li>
<li>将消息记录到当前页面</li>
<li>抛出错误（assert()函数）</li>
</ol>
</li>
</ol>
<h1 id="第19章-E4X"><a href="#第19章-E4X" class="headerlink" title="第19章 E4X"></a>第19章 E4X</h1><ol>
<li><p>E4X 的类型</p>
<ol>
<li><p>E4X = ECMAScript for XML</p>
</li>
<li><p>4个新的全局类型</p>
<ul>
<li>XML: XML 结构中的任何一个独立的部分</li>
<li>XMList: XML 对象的集合</li>
<li>Namespace: 命名空间前缀与命名空间 URI 之间的映射</li>
<li>QName: 由内部名称和命名空间 URI 组成的一个限定名 </li>
</ul>
</li>
</ol>
</li>
</ol>
<p><strong>（Chapter 19 未完待续）</strong></p>
<h1 id="第21章-Ajax-与-Comet"><a href="#第21章-Ajax-与-Comet" class="headerlink" title="第21章 Ajax 与 Comet"></a>第21章 Ajax 与 Comet</h1><ol>
<li><p>XMLHttpRequest 用法</p>
<p> 若不必支持IE7以前的版本，直接使用 XMLHttpRequest 构造函数。</p>
<pre><code>var xhr = new XMLHttpRequest();
</code></pre><p> 紧接着，调用 <code>open()</code> 方法，接受三个参数：请求类型、URL、是否异步发送请求，此时并不会发送真正的请求，而只是启动一个请求准备发送。<br> 要发送特定的请求，需要调用 <code>send()</code> 方法，接受一个参数：请求主体的数据或 null。<br> 对于<strong>异步请求</strong>，需要检测 <code>readyState</code> 属性，来获取当前活动状态。只要 <code>readyState</code> 变化，都会触发 <code>readystatechange</code> 事件。例子如下：</p>
<pre><code>var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
    if(xhr.readyState == 4) {
        if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) {
            alert(xhr.responseText);
        } else {
            alert(&quot;Request was unsuccessful: &quot; + xhr.status);
        }
    }
}
xhr.open(&apos;get&apos;, &apos;example.txt&apos;, true);
</code></pre><p> 在接收到响应之前，可以调用 <code>abort()</code> 方法来取消异步请求。</p>
</li>
<li><p>HTTP 头部信息</p>
<p> <code>setRequestHeader()</code> 方法可以设置自定义的请求头部信息，接受两个参数，键值对。<br> <code>getResponseHeader()</code> 方法传入头部字段，可以取得响应头部信息，而调用 <code>getAllResponseHeaders()</code> 则可以取得包含所有头部信息的长字符串。</p>
</li>
<li><p>GET 请求</p>
<p> 使用 GET 请求查询字符串中每个参数的名称和值都必须使用 encodeURIComponent() 进行编码。</p>
</li>
<li><p>POST 请求</p>
<p> 将数据作为请求的主体提交。</p>
</li>
<li><p>XMLHttpRequest 2级</p>
<ol>
<li>FormData</li>
<li>超时设定</li>
<li>overrideMimeType() 方法</li>
</ol>
</li>
<li><p>进度事件</p>
<p> 6个进度事件：loadstars、progress、error、abort、load、loaded。</p>
<p> progress 事件包含三个属性：lengthComputable、position、totaSize</p>
<p> load 事件与 progress 事件</p>
</li>
<li><p>跨源资源共享</p>
<p> CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求与响应成功还是失败。</p>
<p> 非 IE 浏览器通过 XMLHttpRequest 实现了对 CORS 的原生支持。</p>
</li>
<li><p>跨浏览器的 CORS</p>
<pre><code>function createCORSRequest(method, url) {
    var xhr  = new XMLHttpRequest();
    if(&quot;withCredentials&quot; in xor) {
        xhr.open(method, url, true);
    } else if(typeof XDomainRequest != &quot;undefined&quot;) {
        xhr = new XDomainRequest();
        xhr.open(method, url);
    } else {
        xhr = null;
    }
    return xhr;
}

var request = createCORSRequest(&apos;get&apos;, &apos;http://www.somewhere-else.com/page/&apos;);
if(request) {
    request.onload = function() {
        // 处理 request.responseText
    };
    request.send();
}
</code></pre></li>
<li><p>其他跨域技术</p>
<ol>
<li><p>图像 Ping</p>
<pre><code>var img = new Image();
img.onload = img.onerror = function() {
    alert(&apos;done&apos;);
}
img.src = &apos;url&apos;;
</code></pre><p> 2个缺点：只能发送 GET 请求，无法访问服务器的响应文本。</p>
</li>
<li><p>JSONP</p>
<p> 优点是能够访问响应文本。</p>
</li>
<li><p>Comet</p>
<p> 一种服务器向页面推送数据的技术。两种实现方式：<strong>长轮询和流</strong>（区分短轮询）</p>
</li>
<li><p>Web Sockets</p>
<ol>
<li><p>实例化</p>
<pre><code>var socket = new WebSocket(&apos;ws://www.example.com/server.php&apos;);
</code></pre></li>
<li><p>发送和接收数据</p>
<pre><code>socket.send(&apos;hello world&apos;); // 复杂的数据结构发送之前必须序列化

socket.onmessage = function(event) {
    var data = event.data;
    // ...
}
</code></pre></li>
<li><p>其他事件</p>
<ol>
<li>open：在成功建立连接时触发。</li>
<li>error：在发生错误时触发，连续不能持续。</li>
<li>close：在连接关闭时触发。<code>event</code> 对象还有三个额外的属性：wasClean、code、reason。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="第22章-高级技巧"><a href="#第22章-高级技巧" class="headerlink" title="第22章 高级技巧"></a>第22章 高级技巧</h1><ol>
<li><p>高级函数</p>
<ol>
<li><p>安全的类型检测</p>
<p> 在任何值上调用 Object 原生的 toString() 方法，都会返回一个 <code>[object NativeConstructorName]</code> 格式的字符串。通过 <code>Object.prototype.toString.call(value)</code> 检测。</p>
</li>
<li><p>作用域安全的构造函数</p>
<p> 由于 this 对象实在运行时绑定的，避免因为忽略 new 操作符而导致 this 映射到全局对象 window 上。（P599 例子）</p>
</li>
<li><p>惰性载入函数</p>
<p> 2种实现方式：函数被调用时再处理函数，函数声明时就指定适当的函数（匿名、自执行函数）</p>
</li>
<li><p>函数绑定 bind()</p>
<pre><code>function bind(fn, context) {
    return function() {
        return fn.apply(context, arguments);
    }
}
</code></pre></li>
<li><p>函数柯里化（function currying）</p>
<p> 创建步骤：调用另一个函数并为他传入要柯里化的函数和必要参数。</p>
<pre><code>function curry(fn) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function() {
        var innerArgs = Array.prototype.slice.call(arguments);
        var finalArgs = args.concat(innerArgs);
        return fn.apply(null, finalArgs);
    }
}
</code></pre></li>
</ol>
</li>
<li><p>防篡改对象</p>
<ol>
<li><p>不可扩展对象</p>
<p> 使用 <code>Object.preventExtensions()</code> 方法来不能再给对象添加属性和方法，已有的成员丝毫不受影响。使用 <code>Object.isExtensible()</code> 方法来确定对象是否可以扩展。</p>
</li>
<li><p>密封的对象</p>
<p> 使用 <code>Object.seal()</code> 方法使队形不可扩展，且已有成员的 <code>[[Configurable]]</code> 特性将被设置为 false，意味着不能删除。</p>
<p> 使用 <code>Object.isSealed()</code> 方法确定对象是否已经被密封了。</p>
</li>
<li><p>冻结的对象</p>
<p> 使用 <code>Object.freeze()</code> 方法来冻结对象。在密封的基础上，将已有成员的 <code>[[Writable]]</code> 特性设置为 false。同时有 <code>Object.isFrozen()</code> 方法来检测冻结对象。</p>
</li>
</ol>
</li>
<li><p>高级定时器</p>
<p> JavaScript 中没有任何代码是立刻执行的，但一旦进程空闲则尽快执行。关于定时器要记住的最重要的事情是，指定的时间间隔表示何时将定时器的代码添加到队列，而不是何时实际执行代码。</p>
<p> 避免 <code>setInterval()</code> 重复定时器的2个缺点，可以使用如下模式</p>
<pre><code>setTimeout(function() {
    // TODO
    setTimeout(arguments.callee, interval); // arguments.callee 来获取对当前执行函数的引用
}, interval)
</code></pre></li>
<li><p>Yielding Processes</p>
<p> 运行在浏览器中的 JavaScript 都被分配了一个确定数量的资源，不同于桌面应用往往能够随意控制内存大小和处理器时间，JavaScript 被严格限制了，放置恶意的 Web 程序。</p>
<p> 数组分块技术。</p>
</li>
<li><p>函数节流（重要）</p>
</li>
<li><p>自定义事件</p>
<ol>
<li>属性 handlers：存储事件处理程序。</li>
<li>addHandler()：注册给定类型事件的事件处理程序。</li>
<li>fire()：触发一个事件。</li>
<li>removeHandler()：注销某个事件类型的事件处理程序。</li>
</ol>
</li>
<li><p>拖放（略）</p>
</li>
</ol>
<h1 id="第24章-最佳实践"><a href="#第24章-最佳实践" class="headerlink" title="第24章 最佳实践"></a>第24章 最佳实践</h1><ol>
<li><p>可维护性</p>
<p> 大部分开发人员都花费大量的时间维护他人代码。很难从头开始开发新代码，很多情况下都是以他人工作结果为基础的。</p>
<p> 变量和函数命名：变量名应为名词，函数名应以动词开头，返回布尔类型的函数一般以 <code>is</code> 开头。</p>
<p> 变量类型透明：由于 JavaScript 中变量是松散类型的，很容易忘记变量所应包含的数据类型。三种方式解决：</p>
<pre><code>1. 初始化
2. 匈牙利标记法
3. 类型注释
</code></pre></li>
<li><p>性能</p>
<ol>
<li><p>注意作用域</p>
<ul>
<li>避免全局查找</li>
<li>避免 with 语句</li>
</ul>
</li>
<li><p>选择正确的方法</p>
<ul>
<li>避免不必要的属性查找</li>
<li>优化循环：减值迭代、简化终止条件、简化循环体、使用后测试循环</li>
<li>展开循环</li>
</ul>
</li>
<li><p>最小化语句数</p>
<ul>
<li>多个变量声明</li>
<li>插入迭代值</li>
<li>使用数组和对象字面量</li>
</ul>
</li>
<li><p>优化 DOM 交互</p>
<ol>
<li>最小化现场更新（使用文档片段 createDocumentFragment）</li>
<li>使用 innerHTML</li>
<li>使用事件代理</li>
<li>注意 HTMLCollection</li>
</ol>
</li>
</ol>
</li>
<li><p>部署</p>
</li>
</ol>
<h1 id="第25章-新兴的-API"><a href="#第25章-新兴的-API" class="headerlink" title="第25章 新兴的 API"></a>第25章 新兴的 API</h1><ol>
<li><p>requestAnimationFrame()</p>
<ol>
<li>早期动画循环及 <code>setInterval</code>、<code>setTimeout</code> 利弊</li>
<li>最平滑动画的最佳循环间隔是 1000ms/60，约等于17ms</li>
</ol>
</li>
<li><p>Page Visibility API</p>
<p> 三部分组成：document.hidden、document.visibilityState(4个可能的状态值)、visibility change事件。</p>
</li>
<li><p>Geolocation API</p>
<p> 浏览器中的实现是 navigator.geolocation 对象。</p>
</li>
<li><p>File API</p>
</li>
<li><p>Web 计时</p>
<p> Web 计时机制的核心是 window.performance 对象。</p>
</li>
<li><p>Web Workers</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/06/29/闭包与科利华/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MayorHao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MayorHao的秘密小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/29/闭包与科利华/" itemprop="url">理解闭包与柯里化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-06-29T03:55:29+08:00">
                2016-06-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES6/" itemprop="url" rel="index">
                    <span itemprop="name">ES6</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p></p><p><br>javascript拥有简洁的表达，使你可以专心于算法攻略。就好像黑白机上的闯关游戏，你拾取了宝剑，只需要不停地点<strong>A</strong>就可以了。你唯一要思考的就是如何不停地跳躲Boss的大招。</p><p></p>
<p></p><p>javascript成为浏览器的唯一语言，并且成为世界标准许多年，是有非常重要的理由的。《JavaScript: The Good Parts》做出了非常清晰地解释。</p><p></p>
<p><blockquote><br>    <p> JavaScript:The World’s Most Misunderstood Programming Language</p><br></blockquote></p>
<p></p><p>然而，想要掌握javascript的正确编写方式并不容易。尤其是当你从教科书开始的时候，大部分给你的信息都是面向对象的东西：<strong><code>new</code></strong>， <strong><code>prototype</code></strong>，<strong><code>class</code></strong>，<strong><code>extend</code></strong>，…<br>    </p><p></p>
<p></p><p>这些都不是正确编写javascript的方式，当然你可以这么做，但是你会恨上javascript，这样编写的感觉会让你觉得你在写java却不能拥有java一样的计算速度。</p><p></p>
<p></p><p>想要喜欢上javascript并且享受programming的快感，你需要放下一切对面向对象的理解，走进函数和求值的世界。你的所有代码只有<strong><code>function</code></strong>，这是简单的并且灵活的。<br><br></p><p></p>
<p><hr></p>
<p></p><h1>什么是函数？</h1><p></p>
<p></p><p><br>如同数学界，函数<strong><code>function</code></strong>即代表了求值。然而，从另一个角度来讲，函数<strong><code>function</code></strong>也是值：</p><p></p>
<pre><code>g = f(x)</code></pre>
<p>我们认为g是一个值，来自f函数的计算，输入是x。然而，我们可以把值g作为一个函数，输入y，再次进行求值：</p>
<pre><code>v = g(y)</code></pre>
<p>把函数<strong><code>function</code></strong>赋予值的定位，可以使计算充满了灵活：</p>
<pre><code>v = f(x)(y) = k(f, x, y)</code></pre>
<p><br></p>
<hr>
<h1>什么是柯里化Currying？</h1>
<p><br><strong><code>f(x)(y)</code></strong>就是柯里化：使用函数f，输入x，计算，获得一个新的函数，再次输入y，计算，获取结果。<strong><code>f(x)(y)(z)(a)(b)(c)</code></strong>，你完全可以写这样的函数。每次进行一次计算时，都返回一个新的函数。当然，你也可以写成这样的方式<strong><code>g(x, y, z, a, b, c)</code></strong>。</p>
<pre><code>function f (x) {
  return function (y) {
    return function (z) {
      return function (a) {
        return function (b) {
          return function (c) {
              console.log(x  + y + z + a + b + c);
          };
        };
      };
    };
  };
}</code></pre>
<p>计算6个数字相加为什么要费这么大的周折？原因在于可以获得拥有内部记忆的函数: <strong><code>g = f(1)</code></strong>可以获得一个新的函数<strong><code>g</code></strong>。可以使用<strong><code>g</code></strong>编写多种不同的求值组合，而使第一个输入始终是<strong><code>1</code></strong>:</p>
<pre><code>g(2)(3)(4)(5)(6);
g(3)(3)(4)(5)(6);
g(9)(9)(1)(2)(3);</code></pre>
<p><br></p>
<hr>
<h1>什么是闭包Closure？</h1>
<p><br>上边的函数就是闭包，确切的说，利用柯里化机制的函数<strong><code>function</code></strong>就是闭包函数。通过柯里化，获取一个拥有记忆功能的函数，简化后续的多种计算操作，这就是闭包。</p>
<pre><code>function move(start) {
  var pos = start;
  return function () {
    console.log('Move to ' + (pos += 2) + '.');
  }
}

var move_next = move(6); 
move_next();  // Move to 8. 
move_next();  // Move to 10.</code></pre>
<p><br></p>
<hr>
<h1>进阶：记忆</h1>
<p><br>下面我们来看一下经典的缓存函数。开始有两个输入参数，一个是数组<strong><code>sets</code></strong>，一个是求值函数<strong><code>f</code></strong>：</p>
<pre><code>function memorize(sets, f) {
    var cache = {}; 
    return function (x) { 
        console.log('cache: %j', cache);
        return x in cache
               ? cache[x]
               : cache[x] = f(sets[x]);
    }
}</code></pre>
<p>首先，我们在<strong><code>memorize</code></strong>的内部空间放置了一个记忆单元：<strong><code>cache</code></strong>，是一个<strong><code>Object</code></strong>类型，这样我们就可以用来存储任何我们想要的数据。<strong><code>Object</code></strong>类型可以看做是简化并且统一版的C语言中的<strong><code>struct</code></strong>：不需要考虑链接，不需要考虑类型，解释器会为你完成。</p>
<p>接下来，我们运用柯里化返回一个函数。这个函数有一个输入参数，指定了<strong><code>sets</code></strong>数组中的第几项进行计算。我们首先使用<strong><code>console.log</code></strong>打印当时内部空间的记忆单元<strong><code>cache</code></strong>的值，然后判断输入参数是不是在<strong><code>cache</code></strong>的键中。如果已经存在，直接返回记忆的内容，如果没有存在，使用函数<strong><code>f</code></strong>对输入参数<strong><code>sets[x]</code></strong>求值，然后把结果记忆到内部空间的记忆单元：<strong><code>cache</code></strong>中。</p>
<p>通过记忆，每次使用求值函数<strong><code>f</code></strong>计算后，都将结果保存在<strong><code>cache</code></strong>中，这样可以极大的降低重复计算：</p>
<pre><code>var g = memorize([1000, 2000, 3000], function (x) { return x * x; });
g(0);  // cache: {}，计算1000*1000
g(0);  // cache: {"0":1000000}，来自记忆
g(0);  // cache: {"0":1000000}，来自记忆
g(0);  // cache: {"0":1000000}，来自记忆
g(1);  // cache: {"0":1000000}，计算2000*2000
g(1);  // cache: {"0":1000000, "1":4000000}，来自记忆
g(1);  // cache: {"0":1000000, "1":4000000}，来自记忆</code></pre>
<p><br></p>
<hr>
<h1>进阶：让函数循环起来</h1>
<p><br>我们已经看到了柯里化(闭包)的好处和妙处，同时这些也都是函数<strong><code>function</code></strong>概念帮助我们完成了一系列繁琐的工作。下面我们将把函数<strong><code>function</code></strong>运用到循环中，进一步了解函数的好处和妙处。</p>
<pre><code>function map(sets, f) {
  var i = 0, len = sets.length, result = [], val;  
  while (i &lt; len) {
    val = f(sets[i]);
    result.push(val);
    ++i;
  }
  return result;
}</code></pre>
<p>函数<strong><code>map</code></strong>使用两个输入参数：一个数组<strong><code>sets</code></strong>，一个求值函数<strong><code>f</code></strong>。</p>
<p>首先，我们计算数组<strong><code>sets</code></strong>的长度，设定一个位置符<strong><code>i</code></strong>。然后对<strong><code>sets</code></strong>进行循环的操作，把其中的<strong><code>sets[i]</code></strong>进行求值，然后压入<strong><code>result</code></strong>中，最后将<strong><code>result</code></strong>返回。</p>
<p>通过这样的设定，我们使函数<strong><code>f</code></strong>在循环中运转。我们还可以进一步，再放入一个条件函数，只有条件成功的时候才进行求值：</p>
<pre><code>function map(sets, condf, f) {
  var i = 0, len = sets.length, result = [], val, set;  
  while (i &lt; len) {
    set = sets[i];
    if (condf(set)) {
      val = f(set);
      result.push(val);
    }
    ++i;
  }
  return result;
}</code></pre>
<p>上边我们刚刚讨论了柯里化，所以把这个函数改一改，变成柯里化：</p>
<pre><code>function map(sets, f) {
  return function (condf) {
    var i = 0, len = sets.length, result = [], val, set;  
    while (i &lt; len) {
      set = sets[i];
      if (condf(set)) {
        val = f(set);
        result.push(val);
      }
      ++i;
    }
    return result;
  }
}</code></pre>
<p>现在，函数<strong><code>map</code></strong>在循环中进一步增加了灵活性，我们可以这样方便的使用：</p>
<pre><code>var mymap = map([1,2,3,4,5,6], function (set) { return set + 1; });
mymap(function (set) { return set % 2 === 0 });  // 偶数
mymap(function (set) { return set &gt; 9 });  // 大于9

// 如果你熟悉Ecmascript 6，那么代码会非常有趣
var mymap = map([1,2,3,4,5,6], set =&gt; set + 1);
mymap(set =&gt; set % 2 === 0);  // 偶数
mymap(set =&gt; set &gt; 9 );  // 大于9</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/06/11/判断值相等/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MayorHao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MayorHao的秘密小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/11/判断值相等/" itemprop="url">说说 JS 相等性判断</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-06-11T12:02:00+08:00">
                2016-06-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于 JS 相等性判断，很容易想到严格相等（===）和非严格相等（==），前者在比较前不会进行隐式转换，即若比较的两个值不是相同的类型，比较结果一定是不等的。而后者在进行比较前可能会根据具体情况进行相应的类型转换然后再按照严格比较规则进行比较。</p>
<p><strong>通常情况下使用严格相等是没有问题的，但存在两个例外。一个是+0和-0的比较，另一个是NaN的比较。</strong></p>
<p><strong>在严格相等中，+0 === -0 返回 true，NaN === NaN 返回 false</strong>，这与直观判断是不一致的。为了避免这类特殊情况，可以通过 ES6 新特性 <strong>Object.is</strong> 来进行判断。</p>
<p>Polyfill 也很容易实现，对于+0和-0比较，首先严格相等，再判断倒数是否不相等即可，因为+0/0结果是Infinity，-0/0结果是-Infinity。而对于NaN比较问题，只需要判断二者分别不等于自身即可。（isNaN仅可判断当前数是否是NaN）</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>JavaScript 提供三种不同的比较操作符：严格相等、非严格相等、Object.is。</li>
<li><p>ES2015标准提供以下四种比较操作符：严格相等、非严格相等、零值相等、同值相等。</p>
<ul>
<li>同值相等参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness" target="_blank" rel="external">JavaScript 中相等性判断</a>中 Object.defineProperty 实例，当试图对不可变属性进行修改时可能会发生错误。同值相等由 Object.is 方法提供。</li>
<li>零值相等和同值相等类似，不过会认为 +0 与 -0 相等。</li>
</ul>
</li>
<li>例子可从以下参考链接中获得。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness" target="_blank" rel="external">JavaScript 中相等性判断</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is" target="_blank" rel="external">Object.is</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25107117" target="_blank" rel="external">从 V8 的单元测试源码看“同值相等”</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/01/22/2015-4-6-chapter5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MayorHao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MayorHao的秘密小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/22/2015-4-6-chapter5/" itemprop="url">《HTML&&CSS3入门经典》（5）——表格</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-22T13:01:29+08:00">
                2016-01-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-基本表格元素与特性——用-lt-table-gt-元素创建表格，包含以下特性"><a href="#1-基本表格元素与特性——用-lt-table-gt-元素创建表格，包含以下特性" class="headerlink" title="1. 基本表格元素与特性——用&lt;table&gt;元素创建表格，包含以下特性"></a>1. 基本表格元素与特性——用<code>&lt;table&gt;</code>元素创建表格，包含以下特性</h3><ul>
<li><strong>dir</strong>特性：指定表格文本行文方向。可能取值有 <strong>ltr</strong>和 <strong>rtl</strong></li>
<li><code>&lt;tr&gt;</code>元素包含表格行</li>
<li><code>&lt;td&gt;</code>与<code>&lt;th&gt;</code>元素表示表格单元。前者表示表格数据，后者表示表头信息</li>
<li><strong>colspan</strong>特性：一个单元横跨多个列时</li>
<li><strong>headers</strong>特性：指明哪些表头应该对应所在单元</li>
<li><strong>rowspan</strong>特性：一个单元纵向跨越多少表格行</li>
<li><strong>scope</strong>特性：指定当前表头向哪些单元提供标签和表头信息，可能取值有：row、col、rowgroup、colgroup</li>
</ul>
<h3 id="2-为表格添加标题"><a href="#2-为表格添加标题" class="headerlink" title="2. 为表格添加标题"></a>2. 为表格添加标题</h3><p>使用<code>&lt;caption&gt;</code>元素。多数浏览器在表格之上的中间位置显示该元素的内容</p>
<p>###3. 表格区域分组</p>
<ol>
<li>使用<strong>colspan</strong>特性跨越列</li>
<li>使用<strong>rowspan</strong>特性跨越行</li>
<li>将表格分解为<strong>表头、表体及表尾</strong><ul>
<li><code>&lt;thead&gt;</code>创建独立的表头</li>
<li><code>&lt;tbody&gt;</code>指定表格主体</li>
<li><code>&lt;tfoot&gt;</code>创建独立的表尾</li>
</ul>
</li>
<li>使用<code>&lt;colgroup&gt;</code>元素进行列分组。它直接出现在<code>&lt;table&gt;</code>开标签之后，并包含一个<strong>span</strong>特性，用以指定该组包含了多少列</li>
<li>使用<code>&lt;col&gt;</code>元素在列间共享样式，更多地用于呈现目的</li>
</ol>
<h3 id="4-嵌套表格"><a href="#4-嵌套表格" class="headerlink" title="4. 嵌套表格"></a>4. 嵌套表格</h3><h3 id="5-易访问表格"><a href="#5-易访问表格" class="headerlink" title="5. 易访问表格"></a>5. 易访问表格</h3><p>使用id、scope、headers特性：在<code>&lt;th&gt;</code>元素中添加<strong>scope</strong>特性有助于指定该表头应用于哪些单元，取值有<strong>row、col、rowgroup、colgroup</strong>。在<code>&lt;td&gt;</code>元素中添加 <strong>headers</strong>属性有助于指定哪些表头对应于该单元，该特性的值是一个由空格分隔的表头单元<strong>id</strong>属性值列表。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/01/22/2016-03-10-javascript-guide-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MayorHao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MayorHao的秘密小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/22/2016-03-10-javascript-guide-3/" itemprop="url">《JavaScript 权威指南》笔记（三）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-22T13:01:29+08:00">
                2016-01-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="附录-A-ECMAScript-Harmony"><a href="#附录-A-ECMAScript-Harmony" class="headerlink" title="附录 A ECMAScript Harmony"></a>附录 A ECMAScript Harmony</h1><ol>
<li><p>一般性变化</p>
<ol>
<li>常量（const 声明）</li>
<li>块级作用域及其他作用域（let 声明）</li>
</ol>
</li>
<li><p>函数</p>
<ol>
<li><p>剩余参数与分布参数</p>
<p> Harmony 不再有 arguments 对象，无法通过它来读取未声明的参数。不过使用剩余参数（rest arguments）语法来代替。语法形式为三个点后跟一个标识符。</p>
<p> 分布参数的语法形式与剩余参数的语法相同。唯一的区别是分布参数在调用函数的时候使用，而剩余参数在定义函数的时候使用。</p>
</li>
<li><p>默认参数值</p>
</li>
<li>生成器（yield、next）</li>
</ol>
</li>
<li><p>数组及其他结构</p>
<ol>
<li>迭代器（Iterator 对象）</li>
<li>数组领悟</li>
<li>解构赋值</li>
</ol>
</li>
<li><p>新对象类型</p>
<ol>
<li>代理对象</li>
<li>代理函数</li>
<li>映射与集合</li>
<li>WeekMap（ECMAScript 中唯一能让你知道什么时候对象已经完全解除引用的类型）</li>
<li>StructType</li>
<li>ArrayType</li>
</ol>
</li>
<li><p>类</p>
<ol>
<li>私有成员</li>
<li>getter 和 setter</li>
<li>继承</li>
</ol>
</li>
<li><p>模块（import）</p>
</li>
</ol>
<h1 id="附录-B-严格模式"><a href="#附录-B-严格模式" class="headerlink" title="附录 B 严格模式"></a>附录 B 严格模式</h1><ol>
<li><p>选择使用</p>
<p> <code>&quot;use strict;&quot;</code></p>
</li>
<li><p>变量</p>
<p> 严格模式下，对创建变量和删除变量及变量名有严格限制。非严格模式下会静默失败的情形在严格模式下会抛出错误。</p>
</li>
<li><p>对象</p>
</li>
<li><p>函数</p>
<p> 严格模式下，修改命名参数的值不会反映到 arguments 中，且淘汰了 <code>arguments.callee</code> 和 <code>arguments.caller</code></p>
</li>
<li><p>eval()</p>
</li>
<li><p>eval 与 arguments</p>
<p> 严格模式地已经明确禁止使用 eval 和 arguments 作为标识符。</p>
</li>
<li><p>抑制 this</p>
</li>
<li><p>其他变化</p>
<ol>
<li>抛弃 with 语句</li>
<li>去掉八进制字面量</li>
</ol>
</li>
</ol>
<h1 id="附录-C-JavaScript-库"><a href="#附录-C-JavaScript-库" class="headerlink" title="附录 C JavaScript 库"></a>附录 C JavaScript 库</h1><ol>
<li><p>通用库</p>
<p> 尝试通过使用新 API 包装常见功能来统一浏览器的接口、减少实现差异。</p>
</li>
<li><p>互联网应用</p>
<p> 针对简化完整的 Web 应用开发而设计。</p>
</li>
<li><p>动画和特效</p>
</li>
<li>加密</li>
</ol>
<h1 id="附录-D-JavaScript-工具"><a href="#附录-D-JavaScript-工具" class="headerlink" title="附录 D JavaScript 工具"></a>附录 D JavaScript 工具</h1><ol>
<li>校验器</li>
<li>压缩器</li>
<li>单元测试</li>
<li>文档生成器</li>
<li>安全执行环境</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/01/22/2015-5-24-understand-node-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MayorHao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MayorHao的秘密小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/22/2015-5-24-understand-node-2/" itemprop="url">《深入浅出node.js》笔记（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-22T13:01:29+08:00">
                2016-01-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>初读这部分内容很吃力，尤其是模块编写、模块编译等部分。据说看过Unix相关书籍后再回头看就好理解多了。不过阅读技术书籍的目的不是在于能记住多少，而是建立索引的过程。
</code></pre><h1 id="第二章-模块机制"><a href="#第二章-模块机制" class="headerlink" title="第二章 模块机制"></a>第二章 模块机制</h1><h3 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h3><p>CommonJS规范为JavaScript制定了一个美好的愿景——希望JavaScript能够在任何地方运行。 </p>
<p>CommonJS对模块的定义十分简单，主要分为<strong>模块引用、模块定义和模块标识</strong>三个部分。  </p>
<p>CommonJS构建的这套模块导出和引入机制使得用户完全不必考虑变量污染，命名空间等方案与之相比相形见绌。</p>
<h3 id="Node的模块实现"><a href="#Node的模块实现" class="headerlink" title="Node的模块实现"></a>Node的模块实现</h3><p>在Node中引入模块，需要经历如下3个步骤：</p>
<pre><code>1. 路径分析
2. 文件定位
3. 编译执行
</code></pre><p>在Node中，模块分为两类：一类是Node提供的模块，称为<strong>核心模块</strong>，另一类是用户编写的模块，称为<strong>文件模块</strong>。</p>
<h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><p>核心模块的引入流程：要经历C/C++层面的内建模块定义、（JavaScript）核心模块的定义和引入以及（JavaScript）文件模块层面的引入。但是对于用户而言，<code>require()</code>十分简洁、友好</p>
<h3 id="C-C-扩展模块"><a href="#C-C-扩展模块" class="headerlink" title="C/C++扩展模块"></a>C/C++扩展模块</h3><h3 id="模块调用栈"><a href="#模块调用栈" class="headerlink" title="模块调用栈"></a>模块调用栈</h3><p>核心模块：JavaScript模块 + C/C++内建模块  </p>
<p>文件模块：JavaScript模块 + C/C++扩展模块</p>
<h3 id="包与NPM"><a href="#包与NPM" class="headerlink" title="包与NPM"></a>包与NPM</h3><p>CommonJS包规范是理论，NPM是其中的一种实践。NPM之于Node，相当于gem之于Ruby，pear之于PHP。</p>
<p>安装依赖包：</p>
<ol>
<li>全局模式安装<br> 如执行<code>npm install express -g</code>。需要注意的是，全局模式并不是将一个模块包安装为一个全局包的意思，它并不意味着可以从任何地方通过<code>require()</code>来引用到它。事实上，通过全局模式安装的所有模块包都被安装进了一个统一地目录下。</li>
<li>从本地安装  </li>
<li>从非官方源安装</li>
</ol>
<p>分析包：<br>在使用NPM过程中，或许你不能确认当前目录下能否通过require()顺利引入想要的包，这时可以执行<code>npm ls</code>分析包。该命令可以为你分析出当前路径下能够通过模块路径找到的所有包，并生成依赖树。</p>
<h3 id="前后端共用模块"><a href="#前后端共用模块" class="headerlink" title="前后端共用模块"></a>前后端共用模块</h3><p>AMD规范是CommonJS模块规范的一个延伸。 CMD规范由国内的玉伯提出，与AMD规范的主要区别在于定义模块和依赖引入的部分。</p>
<hr>
<p>（完）</p>
<p>（最后修改于2015-09-23）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/01/22/2015-6-27-note-javascript-dom-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MayorHao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MayorHao的秘密小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/22/2015-6-27-note-javascript-dom-3/" itemprop="url">《JavaScript DOM 编程艺术》笔记（三）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-22T13:01:29+08:00">
                2016-01-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Chapter-6-案例研究：图片库改进版"><a href="#Chapter-6-案例研究：图片库改进版" class="headerlink" title="Chapter 6 案例研究：图片库改进版"></a>Chapter 6 案例研究：图片库改进版</h3><ol>
<li>如果想用Javascript给某个网页添加一些行为，就不应该让Javascript代码对这个网页的结构有任何依赖，凸显了采取预防性措施的必要性。</li>
<li>结构化程序设计原则之一：函数应该只有一个入口和一个出口。但集中将出口集中在函数的开头是可以接受的。</li>
<li>Javascript与HTML标记分离：<code>element.event = function(){...}</code>，这里的event不限于<code>onclick</code>、<code>onkeypress</code></li>
<li><p>共享onload事件<br> 网页加载完毕时会触发一个<code>onload</code>事件，这个事件与window对象相关联。即<code>window.onload = function(){...}</code>。<br> 若需要绑定的函数较多时，一个弹性的解决方案是<code>addLoadEvent</code>，其实现如下：  </p>
<pre><code>function addLoadEvent(func) {  
    var oldonload = window.onload;
    if(typeof window.onload != &apos;function&apos;) {  
        window.onload = func;  
    } else{
        window.onload = function() {
            oldonload();
            func();
        }
    }
}  
</code></pre></li>
<li>DOM Core 和 HTML-DOM</li>
</ol>
<h3 id="Chapter-7-动态创建标记"><a href="#Chapter-7-动态创建标记" class="headerlink" title="Chapter 7 动态创建标记"></a>Chapter 7 动态创建标记</h3><ol>
<li><p>一些传统方法</p>
<ol>
<li>document.write：最大缺点是它违背了“行为应该与表现分离”的原则。即使把document.write<br>语句挪到外部函数里，也还是需要在标记的<code>&lt;body&gt;</code>部分使用<code>&lt;script&gt;</code>标签才能调用那个函数</li>
<li>innerHTML：可用来读、写某给定元素里的HTML内容。使用innerHTML属性，你就可以把JavaScript代码从标记中分离出来。用不着在标记的的<code>&lt;body&gt;</code>部分插入<code>&lt;script&gt;</code>标签</li>
</ol>
</li>
<li><p><strong>DOM方法</strong>(重要)</p>
<ol>
<li>createElement方法：<br> 语法：<code>document.createElement(nodeName);</code><br> 如<code>var para = document.createElement(&quot;p&quot;);</code></li>
<li>appendChild方法：<br> 语法：<code>parent.appendChild(child);</code></li>
<li>createTextNode方法：<br> 语法：<code>document.createTextNode(text);</code></li>
<li>insertBefore方法：<br> 语法：<code>parentElement.insertBefore(newElement, targetElement);</code></li>
<li><p>insertAfter方法：  </p>
<pre><code>function insertAfter(newELement, targetElement) {
    var parent = targetElement.parentNode;
    if(parent.lastChild == targetElement) {
        parent.appendChild(newElement);
    } else {
        parent.insertBefore(newElement, targetElement.nextSibling);
    }
}
</code></pre></li>
</ol>
</li>
<li><p>Ajax</p>
</li>
</ol>
<p>（完）</p>
<p>（最后修改于2015-09-21）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/01/22/2015-6-27-note-javascript-dom-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MayorHao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MayorHao的秘密小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/22/2015-6-27-note-javascript-dom-5/" itemprop="url">《JavaScript DOM 编程艺术》笔记（五）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-22T13:01:29+08:00">
                2016-01-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Chapter-9-CSS-DOM"><a href="#Chapter-9-CSS-DOM" class="headerlink" title="Chapter 9 CSS-DOM"></a>Chapter 9 CSS-DOM</h3><ol>
<li><p>三位一体的网页</p>
<ol>
<li>结构层</li>
<li>表示层</li>
<li>行为层</li>
</ol>
</li>
<li><p>三种技术之间存在潜在的重叠区域。用DOM可以改变网页的结构;CSS利用伪类走进DOM领地，但DOM也可以给元素设定样式。</p>
</li>
<li><p>style属性</p>
<ol>
<li><p>获取样式</p>
<p> 文档的每个<strong>元素节点</strong>都有一个属性<code>style</code>。<code>style</code>属性包含着元素的样式，查询这个属性将返回一个<strong>对象</strong>而不是一个简单的字符串。</p>
<p> 语法为：<code>element.style.property</code></p>
<p> 关于<code>style</code>属性需要注意以下几点：</p>
<ol>
<li>当需要引用一个中间带减号的CSS属性时，DOM要求你使用<strong>驼峰命名法</strong>。CSS属性<code>font-family</code>变为DOM属性<code>fontFamily</code></li>
<li>DOM在表示属性时采用的单位并不总是与它们在CSS样式表里的设置相同。如十六进制设置属性颜色，通过<code>style</code>查询返回结果是rgb格式</li>
<li>style属性只能返回<strong>内嵌样式</strong>，不能检索外部CSS文件声明样式及<code>&lt;head&gt;</code>部分的<code>&lt;style&gt;</code>标签。另外，用DOM设置的样式，可以用DOM检索出来。</li>
</ol>
</li>
<li><p>设置样式</p>
<p> <code>style</code>对象各个属性可读可写。</p>
<p> 语法为：<code>element.style.property = value</code></p>
</li>
</ol>
</li>
<li><p>何时该用DOM脚本设置样式</p>
<ol>
<li><p>根据元素在节点数里的位置来设置样式</p>
<p> 在不考虑CSS3的前提下，CSS还无法根据元素间的相对位置关系找出某个特定的元素，这对DOM并不是什么难题。</p>
<p> Snippet：获取下一个元素节点</p>
<pre><code>function getNextElement(node) {
    if(node.Type == 1) {
        return node;
    }
    if(node.nextSibling) {
        return getNextElement(node.nextSibling);
    }
    return null;
}
</code></pre></li>
<li><p>根据某种条件反复设置某种样式</p>
<p> JavaScript擅长处理重复性任务，用while或for循环就可以轻松遍历一个列表。</p>
<p> Snippet：为表格添加斑马线效果</p>
<pre><code>function stripeTables() {
    if(!document.getElementsByTagName) return false;
    var tables = document.getElementsByTagName(&quot;table&quot;);
    var odd, rows;
    for(var i = 0; i &lt; tables.length; i ++) {
        odd = false;
        rows = document.getElementsByTagName(&quot;tr&quot;);
        for(var j = 0; j &lt; rows.length; j++) {
            if(odd == true) {
                rows[j].style.backgroundColor = &quot;#ffc&quot;;
                odd = false;
            } else {
                odd = true;
            }
        }
    }
}
</code></pre></li>
<li><p>响应事件</p>
<p> 最简单的方案是采用<strong>伪类</strong>，但如果想利用这个伪类在鼠标悬停时改变其他元素的样式，采用DOM。</p>
<p> Snippet：鼠标指针悬停在表格行上方时，该行文本加粗</p>
<pre><code>function highlightRows() {
    if(!document.getElementsByTagName) return false;
    var rows = document.getElementsByTagName(&quot;tr&quot;);
    for(var i = 0; i &lt; rows.length; i++) {
        rows[i].onmouseover = function() {
            this.style.fontWeight = &quot;bold&quot;;
        }
        row[i].onmouseout = function() {
            this.style.fontWeight = &quot;normal&quot;;
        }
    }
}
</code></pre></li>
<li><p>className属性</p>
<p> 与其使用DOM直接改变某个元素的样式，不如通过JavaScript代码去更新这个元素的class属性。</p>
<ol>
<li><p>使用<code>setAttribute()</code>方法：</p>
<p> 语法：<code>element.setAttribte(&quot;class&quot;, &quot;intro&quot;);</code></p>
</li>
<li><p>使用<code>className</code>属性</p>
<p> 语法：<code>element.className = value;</code></p>
<p> 不足：只能替换，不能追加</p>
<p> 完善：利用字符串<strong>拼接操作</strong></p>
<p> 语法：<code>element.className += &quot; intro&quot;;</code>注意赋值的第一个字符是<strong>空格</strong></p>
<p> 实际上我们仅希望在原来确实有一个class的情况下才这么做。</p>
<p> Snippet：addClass</p>
<pre><code>function addClass(element, value) {
    if(!element.className) {
        element.className = value;
    } else {
        var newClassName = &quot; &quot; + value;
        element.className += newClassName;
</code></pre></li>
</ol>
</li>
</ol>
</li>
<li><p>对函数进行抽象</p>
</li>
</ol>
<p>（完）</p>
<p>（最后修改于2015-09-21）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/01/20/2016-01-20-javascript-guide-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MayorHao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MayorHao的秘密小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/20/2016-01-20-javascript-guide-1/" itemprop="url">《JavaScript 权威指南》笔记（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-20T00:50:29+08:00">
                2016-01-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>（Chapter 3 —— Chapter 7）</p>
<hr>
<h1 id="第3章-基本概念"><a href="#第3章-基本概念" class="headerlink" title="第3章 基本概念"></a>第3章 基本概念</h1><ol>
<li><p>严格模式</p>
<p> <code>&quot;use strict&quot;;</code></p>
</li>
<li><p>数据类型</p>
<p>  5种简单数据类型：Undefined Null Boolean Number String。1种复杂数据类型 Object。</p>
</li>
<li><p>typeof 操作符</p>
<p> 可能的返回值，6种数据类型（小写）</p>
<ul>
<li>“undefined”</li>
<li>“boolean”</li>
<li>“string”</li>
<li>“number”</li>
<li>“object”</li>
<li><p>“function”</p>
<p>注意：</p>
</li>
<li><p>typeof null 返回值 ‘object’</p>
</li>
<li>typeof 未声明变量和未初始化变量，均返回 undefined</li>
</ul>
</li>
<li><p>Null 类型</p>
<p> 表示空对象指针，所以 typeof null 返回 object</p>
</li>
<li><p>0/0返回 NaN，正数除以0返回 Infinity，负数除以0返回 -Infinity</p>
</li>
<li>isNaN() 适用于对象。先调用 valueOf()，若不行，再调用 toString()</li>
<li><p>数值转换</p>
<p> Number() parseInt() parseFloat()</p>
<ol>
<li>parseInt() 第二个参数表示按照 X 进制进行解析，即基数。</li>
<li>parseFloat() 只解析十进制</li>
</ol>
</li>
<li><p>toString()</p>
<ol>
<li>null 和 undefined 没有该方法。可以使用转型函数 String()。</li>
<li>可传递一个参数：输出数值的基数。默认情况下，toString()以十进制格式返回数值的字符串表示。</li>
</ol>
</li>
<li><p>Object 类型</p>
<p> Object 的每个实例都有下列的属性和方法：</p>
<ol>
<li>constructor: 构造函数。</li>
<li>hasOwnProperty(propertyName): 用于检查给定的属性是否在当前对象的实例中（而不是实例的原型中）。</li>
<li>isPrototypeOf(object): 用于检查传入的对象是否是传入对象的原型。</li>
<li>propertyIsEnumerable(propertyName): 用于检查给定的属性是否能够使用 for-in 语句。</li>
<li>toLocaleString(): 返回对象的字符串表示，与执行环境的地区对应。</li>
<li>toString(): 返回对象的字符串表示。</li>
<li>valueOf(): 返回对象的字符串、数值或布尔值表示</li>
</ol>
</li>
<li><p>switch 语句在比较值时使用的是全等操作符</p>
</li>
</ol>
<h1 id="第4章-变量、作用域和内存问题"><a href="#第4章-变量、作用域和内存问题" class="headerlink" title="第4章 变量、作用域和内存问题"></a>第4章 变量、作用域和内存问题</h1><ol>
<li><p>基本类型和引用类型</p>
<ul>
<li>基本类型：Undefined、Null、Boolean、Number、String</li>
<li>引用类型：Object</li>
</ul>
</li>
<li><p>只能给引用类型值动态地添加属性</p>
</li>
<li>ECMAScript 中所有函数的参数都是按值传递的（P71）</li>
<li><p>检测类型</p>
<ul>
<li>typeof</li>
<li>instanceof: 检测引用类型的值是什么类型的对象</li>
</ul>
</li>
<li><p>执行环境及作用域</p>
<ol>
<li><p>延长作用域链</p>
<ul>
<li>try-catch 语句的 catch 块</li>
<li>with 语句</li>
</ul>
</li>
</ol>
</li>
<li><p>垃圾收集</p>
<ol>
<li>标记清除</li>
<li>引用计数</li>
</ol>
</li>
<li><p>基本类型值在内存中占据固定大小的空间，被保存在栈空间中</p>
</li>
<li>引用类型的值是对象，保存在堆内存中</li>
</ol>
<h1 id="第5章-引用类型"><a href="#第5章-引用类型" class="headerlink" title="第5章 引用类型"></a>第5章 引用类型</h1><ol>
<li>创建 Object 实例的方式有2种。第一种是使用 new 操作符后跟 Object 构造函数，另一种是使用对象字面量表示法。</li>
<li>一般来说，访问对象属性时使用<strong>点表示法</strong>，不过也可以使用<strong>方括号表示法</strong>来访问对象的属性</li>
<li><p>Array 类型</p>
<ol>
<li>创造数组的两种方式：Array 构造函数（可以省略 new 操作符）、数组字面量表示法。</li>
<li>检测数组： Array.isArray(value)</li>
<li>栈方法：push() pop()</li>
<li>队列方法： push() shift()</li>
<li>重排序方法：reverse() sort()。sort() 方法可以接受一个比较函数作为参数。</li>
<li><p>操作方法：concat() slice() splice()</p>
<p> splice() 主要有3种用法</p>
<ol>
<li>删除：可以删除任意数量的项，指定2个参数：要删除的第一项的位置和要删除的项数。</li>
<li>插入：可以向指定位置插入任意数量的项，指定3个参数：起始位置、0（要删除的项数）和要插入的项。</li>
<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，指定三个参数：起始位置、要删除的项数和要插入的任意数量的项。</li>
</ol>
</li>
<li><p>位置方法：indexOf() lastIndexOf()，两个参数：要查找的项和起始位置</p>
</li>
<li>迭代方法：every() filter() forEach() map() some()</li>
<li>归并方法：reduce() reduceRight()</li>
</ol>
</li>
<li><p>Date 类型</p>
<ol>
<li>Date.parse() Date.UTC()</li>
<li>日期格式化方法（P101）</li>
</ol>
</li>
<li><p>RegExp 类型（略）</p>
</li>
<li><p>Function 类型</p>
<ol>
<li>初始化三种方法：函数声明、函数表达式，第三种是使用 Function 构造函数，理解”函数是对象，函数名是指针”</li>
<li>没有重载</li>
<li>函数内部属性：arguments、this</li>
<li>函数的属性和方法：两个属性：length、prototype，length 表示函数希望接受的命名参数的个数</li>
<li>每个函数都包含两个非继承而来的方法：apply()和call()，区别仅仅是接受参数的方式不同，真正强大的地方是扩充函数赖以运行的作用域。</li>
</ol>
</li>
<li><p>基本包装类型</p>
<p> 3 个特殊的引用类型：Boolean Number String</p>
</li>
<li><p>单体内置对象</p>
<p> 开发人员不必显式地实例化内置对象。例如 Object Array String Global Math</p>
<ol>
<li><p>Global 对象</p>
<ol>
<li><p>URI 编码方法</p>
<ul>
<li>encodeURI、encodeURIComponent：encodeURI()不会对本身属于 URI 的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而 encodeURIComponent()则会对它发现的任何非标准字符进行编码。</li>
<li>decodeURI、decodeURIComponent：对应使用</li>
</ul>
</li>
<li><p>eval()方法：只接受一个参数,即要执行的ECMAScrip(t或JavaScript) 字符串。</p>
</li>
<li>Global 对象属性</li>
<li>window 对象</li>
</ol>
</li>
<li><p>Math 对象</p>
<ol>
<li>Math 的对象属性：Math.E Math.LN10 Math.LN2 Math.LOG2E Math.LOG10E Math.PI Math.SQRT1_2 Math.SQRT2</li>
<li><p><code>min()和max()</code></p>
<p> 这两个方法经常用于避免多余的循环和在 if 语句中确定一组数的最大值，通过使用 <code>apply()</code>方法</p>
<pre><code>var values = [1, 2, 3, 4, 5, 6, 7];
var max = Math.max.apply(Math, values);
</code></pre></li>
<li><p>舍入方法</p>
<ul>
<li>Math.ceil()</li>
<li>Math.floor()</li>
<li>Math.round()</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="第6章-面向对象的程序设计"><a href="#第6章-面向对象的程序设计" class="headerlink" title="第6章 面向对象的程序设计"></a>第6章 面向对象的程序设计</h1><ol>
<li><p>属性类型</p>
<ol>
<li><p>数据类型（Object.defineProperty）</p>
<ul>
<li>configurable: 表示能否通过 delete 删除</li>
<li>writable: 表示能否修改</li>
<li>enumerable: 表示能否通过 for-in 循环返回</li>
<li>value: 属性的数据值</li>
</ul>
</li>
<li><p>访问器属性（只能通过 Object.defineProperty 定义）</p>
<ul>
<li>configurable</li>
<li>enumerable</li>
<li>get</li>
<li>set</li>
</ul>
</li>
</ol>
</li>
<li><p>定义多个属性（Object.defineProperties）</p>
</li>
<li>读取属性的特性（Object.getOwnPropertyDescriptor()）</li>
<li><p>创建对象</p>
<ol>
<li><p>工厂模式</p>
<p> 用函数来封装以特定接口创建对象的细节</p>
<pre><code>function createPerson(name, age, job){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        alert(this.name);
    };
    return o; 
}
</code></pre><p> 工厂模式虽然解决了创建多个相似对象的问题,但却没有解决<strong>对象识别</strong>的问题(即怎样知道一个对象的类型)。</p>
</li>
<li><p>构造函数模式</p>
<p> 之前的例子重写如下：</p>
<pre><code>function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function(){
        alert(this.name);
    }; 
}
var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);
</code></pre></li>
</ol>
</li>
</ol>
<pre><code>    对象的 constructor 属性最初是用来标识对象类型的。创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型。而这正是构造函数模式胜过工厂模式的地方。
    使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。虽然可以通过把函数定义转移到构造函数外部来解决这个问题，但丝毫没有封装性可言。

3. 原型模式

    我们创建的每个函数都有一个 prototype(原型)属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。

        function Person(name, age, job) {
            this.name = name;
            this.age = age;
            this.job = job;
        }

        Person.prototype.sayName = function() {
            console.log(this.name);
        }

    实例通过使用 hasOwnProperty()方法,可以确认什么时候访问的是实例属性（true）,什么时候访问的是原型属性(false)。

    原型与 in 操作符：有两种方式使用 in 操作符:单独使用和在 for-in 循环中使用。在单独使用时,in 操作符会在通过对象能够访问给定属性时返回 true,无论该属性存在于实例中还是原型中。

    封装 hasPrototypeProperty() 确定该属性到底是存在于对象中,还是存在于原型中。

        function hasPrototypeProperty(object, name){
            return !object.hasOwnProperty(name) &amp;&amp; (name in object);
        }



    Object.keys()和 Object.getOwnPropertyNames()方法都可以用来替代 for-in 循环。

    更简单的原型语法：用一个包含所有属性和方法的对象字面量来重写整个原型对象。



        function Person(){

        }


        Person.prototype = {
            name: &quot;Nicholas&quot;,
            age: 29,
            job: &quot;Software Engineer&quot;,
            sayName: function () {
                alert(this.name);
            }
        };



    注意：constructor 属性不再指向 Person 了。除非显示地设置。

    原型的动态性：**重写整个原型对象会出现问题（P156）**

    **原型模式的最大问题是由其共享的本性所导致的。**

4. 组合使用构造函数模式和原型模式

    构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。


5. 动态原型模式

    可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。

6. 寄生构造函数模式（感觉像是工厂模式和构造函数模式的结合）

7. 稳妥构造函数模式
</code></pre><ol>
<li><p>继承</p>
<p> 许多 OO 语言都支持两种继承方式:<strong>接口继承</strong>和<strong>实现继承</strong>。接口继承只继承方法签名，而实现继承则继承实际的方法。如前所述，由于函数没有签名, 在 ECMAScript 中无法实现接口继承。<strong>ECMAScript 只支持实现继承</strong>,而且其实现继承主要是依靠<strong>原型链</strong>来实现的。</p>
</li>
<li><p>原型链</p>
<ol>
<li><p>确定原型和实例的关系</p>
<ol>
<li>instanceof 操作符</li>
<li>isPrototypeOf() 方法</li>
</ol>
</li>
<li><p>原型链的问题</p>
<ol>
<li>最主要的问题来自包含引用类型值的原型。包含引用类型值的原型属性会被所有实例共享。</li>
<li>在创建子类型的实例时,不能向超类型的构造函数中传递参数。（不懂）</li>
</ol>
</li>
</ol>
</li>
<li><p>借用构造函数</p>
</li>
<li><p>组合继承</p>
<p> 组合继承(combination inheritance)，有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。</p>
</li>
<li><p>原型式继承</p>
<pre><code>function object(o) {
    function F() {}
    F.prototype = o;
    return new F();
}
</code></pre></li>
<li><p>寄生式继承</p>
</li>
<li>寄生组合式继承（寄生继承部分依旧不懂）</li>
</ol>
<h1 id="第7章-函数表达式"><a href="#第7章-函数表达式" class="headerlink" title="第7章 函数表达式"></a>第7章 函数表达式</h1><ol>
<li>函数声明的重要特征是<strong>函数声明提升</strong>，也是函数声明与函数表达式的区别。</li>
<li><p><code>arguments.callee</code> 是一个指向正在执行的函数的指针，可以用它来实现对函数的递归调用。递归阶乘函数使用前后：</p>
<pre><code>function factorial(num) {
    if(num &lt;= 1) {
        return 1;
    } else {
        return num * factorial(num-1);
    }
}

function factorial(num) {
    if(num &lt;= 1) {
        return 1;
    } else {
        return num * arguments.callee(num - 1);
    }
}
</code></pre></li>
<li><p><strong>闭包</strong>是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。因为内部函数的作用域链会包含外部函数。</p>
</li>
<li><p>this 对象是在运行时基于函数的执行环境绑定的。两个很典型的例子：</p>
<pre><code>var name = &quot;The Window&quot;;
var object = {
    name : &quot;My Object&quot;,
    getNameFunc : function(){
        return function(){
            return this.name;
        };
    } 
};
alert(object.getNameFunc()()); //&quot;The Window&quot;
</code></pre></li>
</ol>
<pre><code>var name = &quot;he Window&quot;;

var object = {
    name : &quot;My Object&quot;,
    getNameFunc: function() {
        var that = this;
        return function() {
            return that.name;
        }
    }
};
alert(object.getNameFunc()());  //&quot;My Object&quot; 
</code></pre><ol>
<li>模仿块级作用域：匿名函数立即调用</li>
<li><p>私有变量</p>
<ol>
<li><p>特权方法：有权访问私有变量和私有函数的共有方法。缺点是必须使用构造函数模式来达到这个目的。构造函数模式的缺点是每个实例都会创建同样一组新方法，而使用<strong>静态私有变量</strong>来实现特权方法可以避免这个问题</p>
</li>
<li><p>静态私有变量</p>
</li>
<li>模块模式（单例模式）（不懂）</li>
</ol>
</li>
</ol>
<h1 id="第8章-BOM"><a href="#第8章-BOM" class="headerlink" title="第8章 BOM"></a>第8章 BOM</h1><ol>
<li><p>window 对象</p>
<ol>
<li><p>双重角色：表示浏览器的一个实例，是通过 JavaScript 访问浏览器窗口的一个接口，又是 ECMAScript 规定的 Global 对象。</p>
</li>
<li><p>全局作用域</p>
<p> 定义全局变量与在 window 对象上直接定义属性差别：全局变量不能通过 <code>delete</code> 操作符删除，而直接在 window 对象上的定义属性可以。</p>
</li>
<li><p>尝试访问未声明的变量会抛出错误，但是通过查询 window 对象，可以知道某个可能未声明的变量是否存在。</p>
</li>
<li>窗口关系及框架（略）</li>
<li><p>窗口位置</p>
<p> screenLeft screenTop screenX screenY </p>
<p> 移动：moveTo() moveBy()</p>
</li>
<li><p>窗口大小</p>
<p> innerWidth innerHeight outerWidth outerHeight</p>
<p> document.documentElement.clienWidth(clientHeight)         document.body.clientWidth(Height)</p>
</li>
<li><p>导航和打开窗口</p>
<p> window.open() 导航到一个特定 URL 或者打开一个新的浏览器窗口。</p>
<p> 调用 close() 方法可以关闭通过 window.open() 打开的弹出窗口。</p>
</li>
</ol>
</li>
<li><p>location 对象</p>
<ol>
<li><p>既是 window 对象的属性，也是 document 对象的属性。window.location 和 document.location 引用的是同一个对象。</p>
</li>
<li><p>查询字符串参数 location.search</p>
</li>
<li><p>位置操作 window.location 或 location.href</p>
<p>replace() 方法避免生成新纪录。<br>reload() 重新加载。location.reload(true) 从服务器加载，否则可能从缓存中加载。</p>
</li>
</ol>
</li>
<li><p>navigator 对象</p>
</li>
<li><p>screen 对象</p>
<p>基本只用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息。</p>
</li>
<li><p>history 对象</p>
<p>go() back() forward()</p>
</li>
</ol>
<h1 id="第9章-客户端检测"><a href="#第9章-客户端检测" class="headerlink" title="第9章 客户端检测"></a>第9章 客户端检测</h1><ol>
<li><p>能力检测（又称特性检测）</p>
<ol>
<li><p>两个概念</p>
<ul>
<li>先检测达成目的的最常用的特性</li>
<li>必须测试实际要用到的特性。一个特性存在，不一定意味着另一个特性也存在。</li>
</ul>
</li>
<li><p>更可靠的能力检测</p>
<p> 尽量使用 <code>typeof</code></p>
</li>
<li><p>能力检测，不是浏览器检测</p>
</li>
</ol>
</li>
<li><p>怪癖检测</p>
</li>
<li><p>用户代理检测：万不得已的做法</p>
<ol>
<li><p>用户代理字符串检测技术</p>
<ol>
<li>识别呈现引擎：主要检测五大呈现引擎：IE Gecko Webkit KHTML 和 Opera</li>
<li>识别浏览器</li>
<li>识别平台</li>
<li>识别 Windows 操作系统</li>
<li>识别移动设备</li>
<li>识别游戏系统</li>
</ol>
</li>
</ol>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/22/2015-4-1-chapter1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MayorHao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MayorHao的秘密小屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/22/2015-4-1-chapter1/" itemprop="url">《HTML&&CSS3入门经典》（1）——为WEB结构化文档</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-22T02:01:29+08:00">
                2015-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>布尔特性：HTML5中存在一些不是由“名称/值”对组成，而只有一个名称组成的特性。这些特性被称为“不二特性”，如“required”或者“checked”</li>
<li>核心特性：id title class style</li>
<li><p>构成HTML文档基础的四个主要元素:<code>&lt;html&gt;</code>、<code>&lt;head&gt;</code>、<code>&lt;title&gt;</code>和<code>&lt;body&gt;</code></p>
<ol>
<li><code>&lt;html&gt;</code>元素是整个HTML文档的包含元素（containning element）</li>
<li><code>&lt;head&gt;</code>元素仅仅是其它所有头部元素的容器。每个<code>&lt;head&gt;</code>元素内都应包含一个<code>&lt;title&gt;</code>元素，还可以包含以下元素的任意一种按任意顺序出现的组合：<ul>
<li><code>&lt;base&gt;</code></li>
<li><code>&lt;link&gt;</code>：用于链接外部文件，例如样式表：<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;css/main.css&quot;&gt;</code></li>
<li><code>&lt;style&gt;</code>：用于在文档内包含CSS规则</li>
<li><code>&lt;script&gt;</code>：用于在文档内包含脚本</li>
<li><code>&lt;meta&gt;</code>：包含文档的相关信息</li>
</ul>
</li>
<li><code>&lt;title&gt;</code>：搜索引擎使用其内容帮助建立索引</li>
<li><code>&lt;body&gt;</code>:包含了实际浏览器主窗口中看到的部分</li>
<li></li>
</ol>
</li>
<li>关于DOCTYPE：DOCTYPE（即“文档类型”,DOCumentTYPE)，告知浏览器在用户显示文档时应使用何种规则。这些规则称为“模式(mode)”。HTML5将浏览器设置为“严格模式”（strict mode)的DOCTYPE。另一个常见的模式是“兼容模式”(quirks mode)</li>
<li>文本格式化<ol>
<li><code>&lt;pre&gt;</code>：预格式化文本，任何位于<code>&lt;pre&gt;</code>开标签和<code>&lt;/pre&gt;</code>闭标签之间的文本都会保持其在源文件中的格式。大多数浏览器默认会使用等宽字体显示这种文本（Courier字体就是一个等宽字体的例子，每个字母占用相同的宽度）。<code>&lt;pre&gt;</code>元素最常用于显示计算机源码。</li>
</ol>
</li>
<li>理解块级元素与行内元素<ul>
<li>块级（Block-level）元素在屏幕上显示时，就好像在它的首部都有一个换行符</li>
<li>行内（Inline）元素可以出现在同一行句子中而不必另起一行</li>
</ul>
</li>
<li>新增加的元素<ul>
<li><code>&lt;header&gt;</code>：题头对于普通的引导或者内容导航等功能来说非常有帮助</li>
<li><code>&lt;hgroup&gt;</code>:用于组织具有一些逻辑联系的多级标题。</li>
<li><code>&lt;nav&gt;</code>：代表页面的导航区域</li>
<li><code>&lt;section&gt;</code></li>
<li><code>&lt;article&gt;</code></li>
<li><code>&lt;hr&gt;</code>:在页面创建一条横跨页面的横线</li>
<li><code>&lt;blockquote&gt;</code>:引用其他来源的一段文章，使用<strong>cite</strong>指明引用内容特性。此外还有一个<code>&lt;q&gt;</code>元素用于较小的引用</li>
<li><code>&lt;aside&gt;</code>：用于标记文档相关内容，比如醒目引用、边条和广告等</li>
<li><code>&lt;footer&gt;</code></li>
<li><code>&lt;address&gt;</code>:用于标记<code>&lt;article&gt;</code>元素或者整个文档的联络信息</li>
</ul>
</li>
<li>使用列表<ul>
<li>无序列表：<code>&lt;ul&gt;</code></li>
<li>有序列表：<code>&lt;ol&gt;</code><ul>
<li>使用<strong>start</strong>特性修改有序列表的起始数字</li>
<li>使用<strong>reversed</strong>特性实现列表顺序倒数</li>
<li>使用<strong>type</strong>特性制定序列标记</li>
</ul>
</li>
<li>定义列表：<code>&lt;dl&gt;</code>代表一个描述列表，由0个或多个“术语-描述”（名称/值）组构成。每一组都与一个或多个“术语/名称”（<code>&lt;dt&gt;</code>元素的内容）以及一个或多个“描述/值”（<code>&lt;dd&gt;</code>元素的内容）相关联</li>
</ul>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="MayorHao" />
          <p class="site-author-name" itemprop="name">MayorHao</p>
           
              <p class="site-description motion-element" itemprop="description">Calm down and Coding on</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">50</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">54</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MayorHao</span>
</div>



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
